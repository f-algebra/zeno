type bool = true | false;
type nat = 0 | succ nat;
type list = nil | cons nat list;

let rec (add : nat -> nat -> nat) = 
  fun (x : nat) (y : nat) -> 
    case x of
      0 -> y
    | succ x' -> succ (add x' y);
  
let rec (app : list -> list -> list) = 
  fun (xs : list) (ys : list) -> 
    case xs of
      nil -> ys
    | cons x xs' -> cons x (app xs' ys);
    
let rec (rev : list -> list) = 
  fun (xs : list) ->
    case xs of
      nil -> nil
    | cons y ys -> app (rev ys) (cons y nil);
    
let rec (rev2 : list -> list) = 
  fun (xs : list) -> 
    case xs of
    | nil -> nil
    | cons y ys -> 
        case (rev2 ys) of
        | nil -> cons y nil
        | cons z zs -> cons z (app zs (cons y nil));
    
let rec (leq : nat -> nat -> bool) = 
  fun (x : nat) (y : nat) -> 
    case x of
      0 -> true
    | succ x' -> 
        case y of
          0 -> false
        | succ y' -> leq x' y';
        
let rec (len : list -> nat) = 
  fun (xs : list) ->
    case xs of
    | nil -> 0
    | cons y ys -> succ (len ys);
    
prop add_0 =
  all (x : nat) -> add x 0 = x;
  
prop revfalse = 
  all (xs : list) -> rev xs = xs;
  
let rec (app1 : list -> nat -> list) =
  fun (xs : list) (x : nat) -> 
    case xs of
    | nil -> cons x nil
    | cons y ys -> cons y (app1 ys x);
  
simplify 
  fun (xs : list) (x : nat) -> len (rev xs);


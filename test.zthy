type bool = true | false;
type nat = 0 | succ nat;
type list = nil | cons nat list;

let rec (add : nat -> nat -> nat) = 
  fun (x : nat) (y : nat) -> 
    case x of
      0 -> y
    | succ x' -> succ (add x' y);
  
let rec (app : list -> list -> list) = 
  fun (xs : list) (ys : list) -> 
    case xs of
      nil -> ys
    | cons x xs' -> cons x (app xs' ys);
    
let rec (rev : list -> list) = 
  fun (xs : list) ->
    case xs of
      nil -> nil
    | cons x xs' -> app (rev xs') (cons x nil);
    
let rec (rev2 : list -> list) = 
  fun (xs : list) -> 
    case xs of
    | nil -> nil
    | cons y ys -> 
        case (rev2 ys) of
        | nil -> cons y nil
        | cons z zs -> cons z (app zs (cons y nil));
    
let rec (leq : nat -> nat -> bool) = 
  fun (x : nat) (y : nat) -> 
    case x of
      0 -> true
    | succ x' -> 
        case y of
          0 -> false
        | succ y' -> leq x' y';
    
prop add_0 =
  all (x : nat) -> add x 0 = x;
  
prop revfalse = 
  all (xs : list) -> rev xs = xs;
  
check add_0;
check revfalse;

evaluate
  fun (x : nat) (xs : list) -> rev (cons x (cons x xs));
  
simplify 
  fun (xs : list) -> rev2 xs;

